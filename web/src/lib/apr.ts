import type { AprInput, Cashflow } from '@/types/apr';
export function pv(cfs: Cashflow[], i: number): number { let s = 0; for (const { amount, t, f } of cfs) { const denom = (1 + i) ** t * (1 + f * i); s += amount / denom; } return s; }
export function fOfI(i: number, payments: Cashflow[], advances: Cashflow[]): number { return pv(payments, i) - pv(advances, i); }
export function solvePeriodicRate(payments: Cashflow[], advances: Cashflow[], tol = 1e-12, maxIter = 200): number { let lo = 0.0; let hi = 0.5; let flo = fOfI(lo, payments, advances); let fhi = fOfI(hi, payments, advances); let tries = 0; while (flo * fhi > 0 && tries < 24) { hi *= 2; fhi = fOfI(hi, payments, advances); tries++; } if (flo * fhi > 0) { throw new Error('Cannot bracket APR root. Check cashflows and unitsPerYear.'); } for (let k = 0; k < maxIter; k++) { const mid = (lo + hi) / 2; const fmid = fOfI(mid, payments, advances); if (Math.abs(fmid) < tol || Math.abs(hi - lo) < tol) return mid; if (flo * fmid <= 0) { hi = mid; fhi = fmid; } else { lo = mid; flo = fmid; } } throw new Error('APR solve did not converge'); }
export function periodicToAprPercent(i: number, unitsPerYear: number, roundingBps?: number): number { let apr = i * unitsPerYear * 100; if (roundingBps && roundingBps > 0) { const step = roundingBps / 100; apr = Math.round(apr / step) * step; } else { apr = Math.round(apr * 100) / 100; } return apr; }
export function computeAPR(input: AprInput): { aprPct: number; i: number } { const i = solvePeriodicRate(input.payments, input.advances); return { aprPct: periodicToAprPercent(i, input.unitsPerYear, input.roundingBps), i }; }
export function amountFinanced(loanAmount: number, prepaidFinanceCharge: number): number { return loanAmount - prepaidFinanceCharge; }
export function totalOfPayments(payments: Cashflow[]): number { return payments.reduce((s, p) => s + p.amount, 0); }
export function financeCharge(amountFinancedVal: number, totalOfPaymentsVal: number): number { return totalOfPaymentsVal - amountFinancedVal; }
